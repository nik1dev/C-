/*Получить матрицу D[m,n] путем умножения 
матрицы B[m,k] на матрицу E[k,n]. 
Определить в результирующей матрице столбец 
с наибольшей суммой отрицательных элементов. 
Упорядочить этот столбец по убыванию. */

#include <iostream> 
#include <cstdlib> // funct srand
#include <ctime> 
#include <fstream> 
using namespace std; 
int main() {
	setlocale(0,"rus");
	const int n=4; /* объявление длину строк матрицы */  
	int m[n][n];   // объявление массива, куда будет присвоены произведение матриц
	int m1[n][n]; // объявление массива, который будет умножаться с матрицей m2
	int m2[n][n]; // объявление массива, который будет умножаться с матрицей m1
	int v; //Объявление переменной, для оператора switch
	int s(0);  // инициализация переменной, используемая для суммы элементов
	int max(-99); // инициализация переменной используемая для поиска max
	int X(0); // инициализация переменной, используемая как счетчик
	int i(0); // Инициализация переменной, для использования счётчика индекса строк.
	int j(0); // Инициализация переменной, для использования счётчика индекса столбцов.
	int stb(0); // инициализация переменной, для использования поиска stolb
	int t; // объявление переменной, для использования в пузырьке как замена.
	int p(0); // Инициализация переменной, для запоминания произведения матриц B and E
	for (int k=1; k<3; k++) 
	{
		cout<<"Выберите способ сформирования матрици: "<<endl;
		cout<<"1.Файл."<<endl;
		cout<<"2.Клавиатура."<<endl<<"3.Рандом"<<endl;
		cout<<"Выберите один из трёх вариантов"<<endl;
		cin>>v;
		switch (v){//проверка переменной на равество множеству значе-ний(от1 до 3)
		case 1: { //если v=1, то выполняется данное действие, от { до }
		 ofstream f1("1.txt"); //создаем файл, по умолчанию, в папке с файлом, где хранится cpp.
		for (i=0; i<n; ++i)// Создание цикла от нуля, до длины строк матрицы
		{
			for (j=0; j<n; ++j)// Создание цикла от нуля, до длины столбцов матрицы
			{
				if (k==1)
				{
					m1[i][j]=-3+(rand() % 6); //присваивание каждому элементу матрицы случайное число от 0 до 6
					f1<<m1[i][j]<<endl; //вывод значений матрицы, в файл 1.txt
				}
				else 
				{
					m2[i][j]=-3+(rand() % 6);//присваивание каждому элементу матрицы случайное число от 0 до 6
					f1<<m2[i][j]<<endl;//вывод значений матрицы, в файл 1.txt									
				}	
			}
		}
		f1.close();	 //закрытие файла f.1
		ifstream f("1.txt"); // открываю созданный файл 1.txt по умолчанию, в папке с файлом, где хранится cpp.
		while(!f.eof()) // пока файл не пуст, считываем из файла по одному символу 
		{
			if(j==n)
			{
				i++;  //индекс длины строки
				j=0; // индекс длины столбцов
			}
			if (k==1)
			{
				f>>m1[i][j];
				j++;
			}
			else 
			{
				f>>m1[i][j];
				j++;
			}
		}
		f.close();
		break;
		}
		case 2: {
		cout<<"Запишите элементы матрицы: "<<endl;
		for (int i=0; i<n; ++i)
		{
			for (int j=0; j<n; ++j)
			{
				if (k==1)
				{
					cin>>m1[i][j];
				}
				else 
				{
					cin>>m2[i][j];
				}
			}
		}
		break;
		}
		case 3:{
		srand(time(NULL));//выполнение инициализации генератора случайных чисел rand
		for (int i=0; i<n; i++)  
		{
			for (int j=0; j<n; j++) 
			{
				if (k==1)
				{
					m1[i][j]= -3+rand()%10;//Присваивание исходной матрицы случайные числы.
				}
				else 
				{
					m2[i][j]= -3+rand()%10;//Присваивание исходной матрицы случайные числы.
				}
				
			}			
			
		}
		break; 
		}
		default:{//запускается случай по умолчанию, если не один из случаев не был реализован.
		cout<<"Вы ввели не 1,2,3! Перезапустите Программу!";// ����� 
		return 0; }}
	}
    cout<<"Исходная матрица B: "<<endl;
        for (i=0; i<n; i++) 
    {
    	for (j=0; j<n; j++)
    	{
    		cout<<m1[i][j]<<"\t"; 
    	}
    	cout<<endl;
    } 
        cout<<"Исходная матрица E: "<<endl;
        for (i=0; i<n; i++) 
    {
    	for (j=0; j<n; j++)
    	{
    		cout<<m2[i][j]<<"\t"; 
    	}
    	cout<<endl;
    } 
            for (i=0; i<n; i++) 
    {
    	for (j=0; j<n; j++)
    	{
    		for (int k=0; k<n; k++)
			{
				p=(m1[i][k]*m2[k][j])+p;
				m[i][j]=p;				
			}
			p=0; 
    	}
    }
    	cout<<"Полученная матрица D: "<<endl;
        for (i=0; i<n; i++) 
    {
    	for (j=0; j<n; j++)
    	{
    		cout<<m[i][j]<<"\t"; 
    	}
    	cout<<endl;
    } 
            for (i=0; i<n; i++) 
    {
    	for (j=0; j<n; j++)
    	{
    		if (m[j][i] <0)
    		{
    			s=s+m[j][i];
    			X++;
			}
		}
		if (max<s and s!=0)
		{
			max=s;
			stb=i;
		}
		s=0;
	}
	if (X!=0) // защита от дурака, если отрицательных элементы были найдены, то 
	{
		cout<<"Столбец, с максимальной суммой отрицательных элементов столбца: "<<stb+1<<endl;
		for (i = 0; i < n; i++)
		{
			for (int c = 0; c < n - 1; c++)
			{
				if (m[c][stb] < m[c + 1][stb])
				{
					t = m[c][stb];
					m[c][stb] = m[c + 1][stb];
					m[c + 1][stb] = t;
				}
			}
			
		} // цикл для сортировки пузырьком столбца, с наибольшей суммой от-рицательных элементов.
		cout<<"Обработанная матрица D: "<<endl;
		for (i=0; i<n; i++)
		{
			for (j=0; j<n; j++)
			{
				cout<<m[i][j]<<"\t";
			}
			cout<<endl;
		} 
	}
	else // защита от дурака, если все таки отрицательных элементов не было найдено, то выход из программы.
	{
		cout<<"Отрицательных элементов нет."<<endl;
		return 0;
	}
	return 0;
}

